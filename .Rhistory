nof1.binomial.simulation <- function(Base.size = 1000, Treat.size = 1000, alpha = 0.3, beta_A = -0.1, beta_B = -0.05,
rho = 0.5, sigma = 0.5){
Treat <- rep("baseline", Base.size)
Treat <- c(Treat, rep(c("B", "A", "B", "A"), each = Treat.size))
nobs <- length(Treat)
Time <- 1:length(Treat)
Y <- epsilon <- mu <- p <- rep(NA, nobs)
for(i in 1:nobs){
if(i == 1){
epsilon[1] <- rnorm(1, 0, sigma / sqrt(1-rho^2))
} else{
epsilon[i] <- rnorm(1, rho * epsilon[i-1], sigma)
}
# mu[i] <- alpha + epsilon[i]
mu[i] <- alpha
if(Treat[i] == "A"){
mu[i] <- mu[i] + beta_A
} else if (Treat[i] == "B"){
mu[i] <- mu[i] + beta_B
}
Y[i] <- rbinom(1,1, inv_logit(mu[i]))
}
list(Y = Y, Treat = Treat, Time = Time, nobs = nobs)
}
data <- nof1.binomial.simulation()
Y <- data$Y
X <- cbind(1, as.numeric(data$Treat == "A"), as.numeric(data$Treat == "B"))
##############
Bayes.Chib <-function(Y,X, n.samples=1000){
#Initial values:
beta <- rnorm(3)
Z <- rbinom(length(Y), 1, 0.5)
# Keep track of the samples
keep.beta <- matrix(0, n.samples,3)
keep.beta[1,] <- beta
for(i in 2:n.samples){
beta <- mvrnorm(1, mu = solve(t(X)%*%X)%*%t(X)%*%Z, Sigma = solve(t(X) %*% X))
for(k in 1:length(Y)){
if(Y[k] == 1){
Z[k] <- rtnorm(1, X[k,]%*% beta, 1, lower = 0)
} else if(Y[k] == 0){
Z[k] <- rtnorm(1, X[k,]%*% beta, 1, upper = 0)
}
}
keep.beta[i,] <- beta
if(i%%100 == 0) print(i)
}
# Return the posterior samples of beta, sigma, and rho
list(beta=keep.beta)
}
result <- Bayes.Chib(Y,X)
apply(result$beta, 2, median)
print(summary(glm(Y~X-1,family="binomial")))
View(X)
library(msm) #truncated norm
library(MASS)
inv_logit <- function(a){
1/(1+exp(-a))
}
nof1.binomial.simulation <- function(Base.size = 1000, Treat.size = 1000, alpha = 0.4, beta_A = -0.1, beta_B = -0.05,
rho = 0.5, sigma = 0.5){
Treat <- rep("baseline", Base.size)
Treat <- c(Treat, rep(c("B", "A", "B", "A"), each = Treat.size))
nobs <- length(Treat)
Time <- 1:length(Treat)
Y <- epsilon <- mu <- p <- rep(NA, nobs)
for(i in 1:nobs){
if(i == 1){
epsilon[1] <- rnorm(1, 0, sigma / sqrt(1-rho^2))
} else{
epsilon[i] <- rnorm(1, rho * epsilon[i-1], sigma)
}
# mu[i] <- alpha + epsilon[i]
mu[i] <- alpha
if(Treat[i] == "A"){
mu[i] <- mu[i] + beta_A
} else if (Treat[i] == "B"){
mu[i] <- mu[i] + beta_B
}
Y[i] <- rbinom(1,1, inv_logit(mu[i]))
}
list(Y = Y, Treat = Treat, Time = Time, nobs = nobs)
}
data <- nof1.binomial.simulation()
Y <- data$Y
X <- cbind(1, as.numeric(data$Treat == "A"), as.numeric(data$Treat == "B"))
##############
Bayes.Chib <-function(Y,X, n.samples=3000){
#Initial values:
beta <- rnorm(3)
Z <- rbinom(length(Y), 1, 0.5)
# Keep track of the samples
keep.beta <- matrix(0, n.samples,3)
keep.beta[1,] <- beta
for(i in 2:n.samples){
beta <- mvrnorm(1, mu = solve(t(X)%*%X)%*%t(X)%*%Z, Sigma = solve(t(X) %*% X))
for(k in 1:length(Y)){
if(Y[k] == 1){
Z[k] <- rtnorm(1, X[k,]%*% beta, 1, lower = 0)
} else if(Y[k] == 0){
Z[k] <- rtnorm(1, X[k,]%*% beta, 1, upper = 0)
}
}
keep.beta[i,] <- beta
if(i%%100 == 0) print(i)
}
# Return the posterior samples of beta, sigma, and rho
list(beta=keep.beta)
}
result <- Bayes.Chib(Y,X)
apply(result$beta, 2, median)
print(summary(glm(Y~X-1,family="binomial")))
library(msm) #truncated norm
library(MASS)
inv_logit <- function(a){
1/(1+exp(-a))
}
nof1.binomial.simulation <- function(Base.size = 1000, Treat.size = 1000, alpha = 0.5, beta_A = -0.1, beta_B = -0.05,
rho = 0.5, sigma = 0.5){
Treat <- rep("baseline", Base.size)
Treat <- c(Treat, rep(c("B", "A", "B", "A"), each = Treat.size))
nobs <- length(Treat)
Time <- 1:length(Treat)
Y <- epsilon <- mu <- p <- rep(NA, nobs)
for(i in 1:nobs){
if(i == 1){
epsilon[1] <- rnorm(1, 0, sigma / sqrt(1-rho^2))
} else{
epsilon[i] <- rnorm(1, rho * epsilon[i-1], sigma)
}
mu[i] <- alpha + epsilon[i]
if(Treat[i] == "A"){
mu[i] <- mu[i] + beta_A
} else if (Treat[i] == "B"){
mu[i] <- mu[i] + beta_B
}
Y[i] <- rbinom(1,1, inv_logit(mu[i]))
}
list(Y = Y, Treat = Treat, Time = Time, nobs = nobs)
}
data <- nof1.binomial.simulation()
Y <- data$Y
X <- cbind(1, as.numeric(data$Treat == "A"), as.numeric(data$Treat == "B"))
##############
Bayes.Chib.correleated <-function(Y,X, n.samples=1000){
n <- length(Y)
#Initial values:
beta <- rnorm(3)
Z <- rbinom(n, 1, 0.5)
W <- rnorm(n, 0, 1)
sigma2 <- runif(1, 0, 1)
rho <- runif(1, -1, 1)
# Keep track of the samples
keep.beta <- matrix(0,n.samples,3)
keep.beta[1,] <- beta
keep.rho <- keep.sigma2 <- rep(0, n.samples)
keep.sigma2[1] <- sigma2
keep.rho <- rho
for(i in 2:n.samples){
beta <- mvrnorm(1, mu = solve(t(X)%*%X)%*%t(X)%*%(Z-W), Sigma = solve(t(X) %*% X))
rho <- rtnorm(1, sum(W[-n] * W[-1]) / sum(W[c(-1, -n)]^2), sigma2/sum(W[c(-1, -n)]^2), lower = -1, upper = 1)
sigma2 <- 1/rgamma(1,n/2, 1/2 * (sum((W[-1] - rho * W[-n])^2) + (1- rho^2) *W[1]^2))
W[1] <- rnorm(1, (1/sigma2 + 1)^-1 * (rho/sigma2 * W[2] + Z[1] - X[1,] %*% beta), sqrt((1/sigma2 + 1)^-1))
for(j in 2:(n-1)){
W[j] <- rnorm(1, ((1+rho^2)/sigma2 + 1)^-1 * (rho/sigma2 * (W[j-1] + W[j+1]) + Z[j] - X[j,] %*% beta), sqrt(((1+rho^2)/sigma2 + 1)^-1))
}
W[n] <- rnorm(1, (1/sigma2 + 1)^-1 * (rho/sigma2 * W[n-1] + Z[n] - X[n,] %*% beta), sqrt((1/sigma2 + 1)^-1))
for(k in 1:n){
if(Y[k] == 1){
Z[k] <- rtnorm(1, X[k,]%*% beta + W[k], 1, lower = 0)
} else if(Y[k] == 0){
Z[k] <- rtnorm(1, X[k,]%*% beta + W[k], 1, upper = 0)
}
}
keep.beta[i,] <- beta
keep.sigma2[i] <- sigma2
keep.rho[i] <- rho
if(i%%100 == 0) print(i)
}
# Return the posterior samples of beta, sigma, and rho
list(beta=keep.beta, sigma2 = keep.sigma2, rho =keep.rho)
}
result <- Bayes.Chib.correlated(Y,X)
apply(result$beta, 2, median)
apply(result$sigma2, 2, median)
apply(result$rho, 2, median)
#print(summary(glm(Y~X-1,family="binomial")))
library(msm) #truncated norm
library(MASS)
inv_logit <- function(a){
1/(1+exp(-a))
}
nof1.binomial.simulation <- function(Base.size = 1000, Treat.size = 1000, alpha = 0.5, beta_A = -0.1, beta_B = -0.05,
rho = 0.5, sigma = 0.5){
Treat <- rep("baseline", Base.size)
Treat <- c(Treat, rep(c("B", "A", "B", "A"), each = Treat.size))
nobs <- length(Treat)
Time <- 1:length(Treat)
Y <- epsilon <- mu <- p <- rep(NA, nobs)
for(i in 1:nobs){
if(i == 1){
epsilon[1] <- rnorm(1, 0, sigma / sqrt(1-rho^2))
} else{
epsilon[i] <- rnorm(1, rho * epsilon[i-1], sigma)
}
mu[i] <- alpha + epsilon[i]
if(Treat[i] == "A"){
mu[i] <- mu[i] + beta_A
} else if (Treat[i] == "B"){
mu[i] <- mu[i] + beta_B
}
Y[i] <- rbinom(1,1, inv_logit(mu[i]))
}
list(Y = Y, Treat = Treat, Time = Time, nobs = nobs)
}
data <- nof1.binomial.simulation()
Y <- data$Y
X <- cbind(1, as.numeric(data$Treat == "A"), as.numeric(data$Treat == "B"))
##############
Bayes.Chib.correlated <-function(Y,X, n.samples=1000){
n <- length(Y)
#Initial values:
beta <- rnorm(3)
Z <- rbinom(n, 1, 0.5)
W <- rnorm(n, 0, 1)
sigma2 <- runif(1, 0, 1)
rho <- runif(1, -1, 1)
# Keep track of the samples
keep.beta <- matrix(0,n.samples,3)
keep.beta[1,] <- beta
keep.rho <- keep.sigma2 <- rep(0, n.samples)
keep.sigma2[1] <- sigma2
keep.rho <- rho
for(i in 2:n.samples){
beta <- mvrnorm(1, mu = solve(t(X)%*%X)%*%t(X)%*%(Z-W), Sigma = solve(t(X) %*% X))
rho <- rtnorm(1, sum(W[-n] * W[-1]) / sum(W[c(-1, -n)]^2), sigma2/sum(W[c(-1, -n)]^2), lower = -1, upper = 1)
sigma2 <- 1/rgamma(1,n/2, 1/2 * (sum((W[-1] - rho * W[-n])^2) + (1- rho^2) *W[1]^2))
W[1] <- rnorm(1, (1/sigma2 + 1)^-1 * (rho/sigma2 * W[2] + Z[1] - X[1,] %*% beta), sqrt((1/sigma2 + 1)^-1))
for(j in 2:(n-1)){
W[j] <- rnorm(1, ((1+rho^2)/sigma2 + 1)^-1 * (rho/sigma2 * (W[j-1] + W[j+1]) + Z[j] - X[j,] %*% beta), sqrt(((1+rho^2)/sigma2 + 1)^-1))
}
W[n] <- rnorm(1, (1/sigma2 + 1)^-1 * (rho/sigma2 * W[n-1] + Z[n] - X[n,] %*% beta), sqrt((1/sigma2 + 1)^-1))
for(k in 1:n){
if(Y[k] == 1){
Z[k] <- rtnorm(1, X[k,]%*% beta + W[k], 1, lower = 0)
} else if(Y[k] == 0){
Z[k] <- rtnorm(1, X[k,]%*% beta + W[k], 1, upper = 0)
}
}
keep.beta[i,] <- beta
keep.sigma2[i] <- sigma2
keep.rho[i] <- rho
if(i%%100 == 0) print(i)
}
# Return the posterior samples of beta, sigma, and rho
list(beta=keep.beta, sigma2 = keep.sigma2, rho =keep.rho)
}
result <- Bayes.Chib.correlated(Y,X)
apply(result$beta, 2, median)
apply(result$sigma2, 2, median)
apply(result$rho, 2, median)
#print(summary(glm(Y~X-1,family="binomial")))
mean(result$sigma2)
mean(result$rho)
plot(result$rho)
plot(result$rho)
plot(result$sigma2)
plot(result$beta[,1])
plot(result$beta[,2])
plot(result$beta[,3])
plot(result$sigma2)
remove(list = ls())
library(msm) #truncated norm
library(MASS)
inv_logit <- function(a){
1/(1+exp(-a))
}
nof1.binomial.simulation <- function(Base.size = 1000, Treat.size = 1000, alpha = 0.5, beta_A = -0.1, beta_B = -0.05,
rho = 0.5, sigma = 0.5){
Treat <- rep("baseline", Base.size)
Treat <- c(Treat, rep(c("B", "A", "B", "A"), each = Treat.size))
nobs <- length(Treat)
Time <- 1:length(Treat)
Y <- epsilon <- mu <- p <- rep(NA, nobs)
for(i in 1:nobs){
if(i == 1){
epsilon[1] <- rnorm(1, 0, sigma / sqrt(1-rho^2))
} else{
epsilon[i] <- rnorm(1, rho * epsilon[i-1], sigma)
}
mu[i] <- alpha + epsilon[i]
if(Treat[i] == "A"){
mu[i] <- mu[i] + beta_A
} else if (Treat[i] == "B"){
mu[i] <- mu[i] + beta_B
}
Y[i] <- rbinom(1,1, inv_logit(mu[i]))
}
list(Y = Y, Treat = Treat, Time = Time, nobs = nobs)
}
data <- nof1.binomial.simulation()
Y <- data$Y
X <- cbind(1, as.numeric(data$Treat == "A"), as.numeric(data$Treat == "B"))
##############
Bayes.Chib.correlated <-function(Y,X, n.samples=10000){
n <- length(Y)
#Initial values:
beta <- rnorm(3)
Z <- rbinom(n, 1, 0.5)
W <- rnorm(n, 0, 1)
sigma2 <- runif(1, 0, 1)
rho <- runif(1, -1, 1)
# Keep track of the samples
keep.beta <- matrix(0,n.samples,3)
keep.beta[1,] <- beta
keep.rho <- keep.sigma2 <- rep(0, n.samples)
keep.sigma2[1] <- sigma2
keep.rho <- rho
for(i in 2:n.samples){
beta <- mvrnorm(1, mu = solve(t(X)%*%X)%*%t(X)%*%(Z-W), Sigma = solve(t(X) %*% X))
rho <- rtnorm(1, sum(W[-n] * W[-1]) / sum(W[c(-1, -n)]^2), sigma2/sum(W[c(-1, -n)]^2), lower = -1, upper = 1)
sigma2 <- 1/rgamma(1,n/2, 1/2 * (sum((W[-1] - rho * W[-n])^2) + (1- rho^2) *W[1]^2))
W[1] <- rnorm(1, (1/sigma2 + 1)^-1 * (rho/sigma2 * W[2] + Z[1] - X[1,] %*% beta), sqrt((1/sigma2 + 1)^-1))
for(j in 2:(n-1)){
W[j] <- rnorm(1, ((1+rho^2)/sigma2 + 1)^-1 * (rho/sigma2 * (W[j-1] + W[j+1]) + Z[j] - X[j,] %*% beta), sqrt(((1+rho^2)/sigma2 + 1)^-1))
}
W[n] <- rnorm(1, (1/sigma2 + 1)^-1 * (rho/sigma2 * W[n-1] + Z[n] - X[n,] %*% beta), sqrt((1/sigma2 + 1)^-1))
for(k in 1:n){
if(Y[k] == 1){
Z[k] <- rtnorm(1, X[k,]%*% beta + W[k], 1, lower = 0)
} else if(Y[k] == 0){
Z[k] <- rtnorm(1, X[k,]%*% beta + W[k], 1, upper = 0)
}
}
keep.beta[i,] <- beta
keep.sigma2[i] <- sigma2
keep.rho[i] <- rho
if(i%%100 == 0) print(i)
}
# Return the posterior samples of beta, sigma, and rho
list(beta=keep.beta, sigma2 = keep.sigma2, rho =keep.rho)
}
result <- Bayes.Chib.correlated(Y,X)
remove(list = ls())
library(msm) #truncated norm
library(MASS)
inv_logit <- function(a){
1/(1+exp(-a))
}
nof1.binomial.simulation <- function(Base.size = 1000, Treat.size = 1000, alpha = 0.5, beta_A = -0.1, beta_B = -0.05,
rho = 0.5, sigma = 0.5){
Treat <- rep("baseline", Base.size)
Treat <- c(Treat, rep(c("B", "A", "B", "A"), each = Treat.size))
nobs <- length(Treat)
Time <- 1:length(Treat)
Y <- epsilon <- mu <- p <- rep(NA, nobs)
for(i in 1:nobs){
if(i == 1){
epsilon[1] <- rnorm(1, 0, sigma / sqrt(1-rho^2))
} else{
epsilon[i] <- rnorm(1, rho * epsilon[i-1], sigma)
}
mu[i] <- alpha + epsilon[i]
if(Treat[i] == "A"){
mu[i] <- mu[i] + beta_A
} else if (Treat[i] == "B"){
mu[i] <- mu[i] + beta_B
}
Y[i] <- rbinom(1,1, inv_logit(mu[i]))
}
list(Y = Y, Treat = Treat, Time = Time, nobs = nobs)
}
data <- nof1.binomial.simulation()
Y <- data$Y
X <- cbind(1, as.numeric(data$Treat == "A"), as.numeric(data$Treat == "B"))
##############
Bayes.Chib.correlated <-function(Y,X, n.samples=10000){
n <- length(Y)
#Initial values:
beta <- rnorm(3)
Z <- rbinom(n, 1, 0.5)
W <- rnorm(n, 0, 1)
sigma2 <- runif(1, 0, 1)
rho <- runif(1, -1, 1)
# Keep track of the samples
keep.beta <- matrix(0,n.samples,3)
keep.beta[1,] <- beta
keep.rho <- keep.sigma2 <- rep(0, n.samples)
keep.sigma2[1] <- sigma2
keep.rho <- rho
for(i in 2:n.samples){
beta <- mvrnorm(1, mu = solve(t(X)%*%X)%*%t(X)%*%(Z-W), Sigma = solve(t(X) %*% X))
rho <- rtnorm(1, sum(W[-n] * W[-1]) / sum(W[c(-1, -n)]^2), sqrt(sigma2/sum(W[c(-1, -n)]^2)), lower = -1, upper = 1)
sigma2 <- 1/rgamma(1,n/2, 1/2 * (sum((W[-1] - rho * W[-n])^2) + (1- rho^2) *W[1]^2))
W[1] <- rnorm(1, (1/sigma2 + 1)^-1 * (rho/sigma2 * W[2] + Z[1] - X[1,] %*% beta), sqrt((1/sigma2 + 1)^-1))
for(j in 2:(n-1)){
W[j] <- rnorm(1, ((1+rho^2)/sigma2 + 1)^-1 * (rho/sigma2 * (W[j-1] + W[j+1]) + Z[j] - X[j,] %*% beta), sqrt(((1+rho^2)/sigma2 + 1)^-1))
}
W[n] <- rnorm(1, (1/sigma2 + 1)^-1 * (rho/sigma2 * W[n-1] + Z[n] - X[n,] %*% beta), sqrt((1/sigma2 + 1)^-1))
for(k in 1:n){
if(Y[k] == 1){
Z[k] <- rtnorm(1, X[k,]%*% beta + W[k], 1, lower = 0)
} else if(Y[k] == 0){
Z[k] <- rtnorm(1, X[k,]%*% beta + W[k], 1, upper = 0)
}
}
keep.beta[i,] <- beta
keep.sigma2[i] <- sigma2
keep.rho[i] <- rho
if(i%%100 == 0) print(i)
}
# Return the posterior samples of beta, sigma, and rho
list(beta=keep.beta, sigma2 = keep.sigma2, rho =keep.rho)
}
result <- Bayes.Chib.correlated(Y,X)
apply(result$beta, 2, median)
apply(result$sigma2, 2, median)
apply(result$rho, 2, median)
#print(summary(glm(Y~X-1,family="binomial")))
apply(result$beta, 2, median)
mean(result$sigma2)
mean(result$rho)
plot(result$sigma2)
plot(result$rho)
apply(result$beta, 2, median)
library(msm) #truncated norm
library(MASS)
inv_logit <- function(a){
1/(1+exp(-a))
}
nof1.binomial.simulation <- function(Base.size = 1000, Treat.size = 1000, alpha = 0.1, beta_A = 0.2, beta_B = -0.2,
rho = 0.5, sigma = 0.1){
Treat <- rep("baseline", Base.size)
Treat <- c(Treat, rep(c("B", "A", "B", "A"), each = Treat.size))
nobs <- length(Treat)
Time <- 1:length(Treat)
Y <- epsilon <- mu <- p <- rep(NA, nobs)
for(i in 1:nobs){
if(i == 1){
epsilon[1] <- rnorm(1, 0, sigma / sqrt(1-rho^2))
} else{
epsilon[i] <- rnorm(1, rho * epsilon[i-1], sigma)
}
mu[i] <- alpha + epsilon[i]
if(Treat[i] == "A"){
mu[i] <- mu[i] + beta_A
} else if (Treat[i] == "B"){
mu[i] <- mu[i] + beta_B
}
Y[i] <- rbinom(1,1, inv_logit(mu[i]))
}
list(Y = Y, Treat = Treat, Time = Time, nobs = nobs)
}
data <- nof1.binomial.simulation()
Y <- data$Y
X <- cbind(1, as.numeric(data$Treat == "A"), as.numeric(data$Treat == "B"))
##############
Bayes.Chib.correlated <-function(Y,X, n.samples=10000){
n <- length(Y)
#Initial values:
beta <- rnorm(3)
Z <- rbinom(n, 1, 0.5)
W <- rnorm(n, 0, 1)
sigma2 <- runif(1, 0, 1)
rho <- runif(1, -1, 1)
# Keep track of the samples
keep.beta <- matrix(0,n.samples,3)
keep.beta[1,] <- beta
keep.rho <- keep.sigma2 <- rep(0, n.samples)
keep.sigma2[1] <- sigma2
keep.rho <- rho
for(i in 2:n.samples){
beta <- mvrnorm(1, mu = solve(t(X)%*%X)%*%t(X)%*%(Z-W), Sigma = solve(t(X) %*% X))
rho <- rtnorm(1, sum(W[-n] * W[-1]) / sum(W[c(-1, -n)]^2), sqrt(sigma2/sum(W[c(-1, -n)]^2)), lower = -1, upper = 1)
sigma2 <- 1/rgamma(1,n/2, 1/2 * (sum((W[-1] - rho * W[-n])^2) + (1- rho^2) *W[1]^2))
W[1] <- rnorm(1, (1/sigma2 + 1)^-1 * (rho/sigma2 * W[2] + Z[1] - X[1,] %*% beta), sqrt((1/sigma2 + 1)^-1))
for(j in 2:(n-1)){
W[j] <- rnorm(1, ((1+rho^2)/sigma2 + 1)^-1 * (rho/sigma2 * (W[j-1] + W[j+1]) + Z[j] - X[j,] %*% beta), sqrt(((1+rho^2)/sigma2 + 1)^-1))
}
W[n] <- rnorm(1, (1/sigma2 + 1)^-1 * (rho/sigma2 * W[n-1] + Z[n] - X[n,] %*% beta), sqrt((1/sigma2 + 1)^-1))
for(k in 1:n){
if(Y[k] == 1){
Z[k] <- rtnorm(1, X[k,]%*% beta + W[k], 1, lower = 0)
} else if(Y[k] == 0){
Z[k] <- rtnorm(1, X[k,]%*% beta + W[k], 1, upper = 0)
}
}
keep.beta[i,] <- beta
keep.sigma2[i] <- sigma2
keep.rho[i] <- rho
if(i%%100 == 0) print(i)
}
# Return the posterior samples of beta, sigma, and rho
list(beta=keep.beta, sigma2 = keep.sigma2, rho =keep.rho)
}
result <- Bayes.Chib.correlated(Y,X)
apply(result$beta, 2, median)
mean(result$sigma2)
mean(result$rho)
#print(summary(glm(Y~X-1,family="binomial")))
plot(result$beta[,1])
plot(result$beta[,2])
plot(result$beta[,3])
plot(result$rho)
0.1^2
sqrt(0.16)
plot(result$rho)
plot(result$sigma2)
plot(result$beta[,1])
plot(result$beta[,2])
plot(result$beta[,3])
getwd()
